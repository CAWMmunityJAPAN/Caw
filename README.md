# CawUsernames

Solidity project for the backend of the CAW social network. Read more about this project in the manifesto: https://caw.is

# View the Rinkeby contract here:

Testnet NFT contract address: https://rinkeby.etherscan.io/address/0xf6e0033f3b225520d2a8c72c8fa1834dc666ad8f

View NFTS on testnet opensea: https://testnets.opensea.io/collection/caw-name-v3

This contract was written in a way that ensures permanent ownership and permanent pricing for minting Caw Usernames, but allows the deployer to change the metadata and the display image by assigning a new display generating contract address. The current display is generated by this contract: https://rinkeby.etherscan.io/address/0x56f0d5da1bc735e03d6a4cd988784ed498fd9ee3#readContract

In the near future, there will be an interface where you can get a username NFT, but for now,

**TO MINT A USERNAME ON TESTNET, follow these instructions:**

  - You must first set your metamask to 'Rinkeby',
  
Then mint some `MintableCaw (mCAW)`:
  - Navigate here: https://rinkeby.etherscan.io/address/0x21121c9f9289cf38ddff7763bb4b0735bf78afcd#writeContract
  - Connect web3
  - Click MINT
  - enter your wallet address in the account field
  - enter a large number in the amount field (with 18 decimals)
  - Then click 'Write'

Then approve mCAW spending of the NFT contract address.
 - navigate here: https://rinkeby.etherscan.io/address/0x21121c9f9289cf38ddff7763bb4b0735bf78afcd#writeContract
 - Connect web3
 - Click 'approve'
 - enter your balance (with 18 decimals) in the 'amount field'
 - and this address 0xf6e0033f3b225520d2a8c72c8fa1834dc666ad8f in the 'Spender' field
 - Then click 'Write'

Once you do that, you'll be able to mint an NFT username.
 - Navigate here: https://rinkeby.etherscan.io/address/0xf6e0033f3b225520d2a8c72c8fa1834dc666ad8f#writeContract
 - Connect web3
 - Click 'mint'
 - enter the username you wish to mint
 - Then click 'Write'



# Approach and reasoning surrounding the deails of this project:

A decentralized social network comes with a number of difficult problems, especially when the
primary source of truth (the etherum blockchain) requires significant fees to store data.

The proposed approach (as implied by <a href='https://caw.is'>CAW manifesto</a>)
is to have a second source of truth, a decentralized database (possibly ARWeave or OrbitDB),
along side the ethereum blockchain.

Due to the open nature of a decentralized database, anyone will be able to post anything to
this database at any time, which allows for many avenues of data injection attacks.
The following is a list of security requirements:

```
  a) Only the owner of a CawName can make a post with that CawName
  b) A CawName must spend CAW (as specified by the manifesto) for each action to be valid 
  c) Actions sent from a CawName under a previous owner should still be valid
  d) A single action must only be processed on the blockchain once
```

Each of these requirements have been accounted for in the `verifySignature` method in the contract.


The proposed solution to these requirements is to use OrbitDB with the following decentralized databases:

```
  i)   A single global action-feed for 'pending actions'
  ii)  A single global caw-feed for all newly verified caws and re-caws
  iii) A CawName specific caw-feed containing caws posted by that CawName
  iv)  A hashtag specific caw-feed for each and every hashtag used
  v)   A CawName specific caw-feed containing the caws posted from the followers of the specified CawName
  vi)  A CawName specific non-caw-feed containing all actions posted from a CawName
```


When a user takes any action (cawing -posting a caw-, liking a caw, following a user, recawing a caw, tipping a user),
the front-end client will assemble the necessary data in the format of the struct ActionData found in the
CawName contract, as follows:

```
  struct ActionData {
    ActionType actionType;
    uint64 senderTokenId;
    uint64 receiverTokenId;
    uint256 tipAmount;
    uint64 timestamp;
    address sender;
    bytes32 cawId;
    string text;
  }
```

The user will sign this ActionData, and the front-end client will submit both the ActionData and the signature to the
global 'pending actions' database (i). If the action is a caw, it will submit it to the caw-feed for that cawName (iii).

In the case of a Caw, the `cawId` and `receiverTokenId` fields should be left empty (0x000...00, and 0 respectively),
and in the case of all other actions, the `text` field should be left empty (""). 

The actionType should be a uint8 which corresponds to the intended index of the following enum:

```
{ CAW, LIKE, RECAW, FOLLOW }
```

(e.g. 0 for CAW; 1 for LIKE; etc..)


Once there are enough pending actions, a validator will retreive them from the db and submit them to the `processActions` function
in the CawActions contract. This function verifies each signature, and spends and distributes the intended amounts of CAW. It then
uses the first 32 bytes of the signature as an acitonId, and marks it as "verified" so at a later point a client can easily check if
the action has been process and paid for.

If the action failed while being processed, the contract will emit an ActionRejected event along with the senderId, actionId,
and the reason of failure. If an action succeeds, it will emit an `ActionProcessed` event along with the senderId and the actionId.

Once each action is marked as successfully processed, the validator can then post those actions to the databases ii, iv, v, vi,
as dictated by the content and sender of the CAW. This logic will be built into the validator codebse, which will be runnable by
anyone who chooses to be a validator.

It's important to remember that before a validator processes an action, it will be publicly readable from the database,
but not yet paid-for on the blockchain. Because of this paradigm, it's important that any front-end client makes a request
to the blockchain to check on the validity and completeness of each of caw before displaying them to the user
(or at minimum, notes the unpaid caw as 'unverified' to the user).

To check the validity of a caw, the front-end client can make a call to `verifyActions` with an array of the `senderIds` and
a corresponding array of `actionIds`. This will return an array of booleans indicating whether or not the caw at the
corresponding index has been processed, paid for, and marked as verified.

With this returned data, the front-end client now knows which caws have valid signatures. But before rendering caws with valid signatures
to users, it is also important for the front-end client to verifiy the following:

  - All fields which are expected to be empty for the specified `actionType`, must be verified as empty.
    If this is not the case, it's possible that a neferious user could be using the data in these fields
    to forge a signature which immitates the signature of another valid action.

  - It must be verified that the specified data is in fact full, complete, and was sent alongside the specified signature.
    This can be verified by using the web3 `recoverTypedSignature` function, which uses the signature and the data to recover the address
    of the original signer. If the address of the signer matches the sender address within the ActionData, then we know that the data is 
    veracious.

Once the data and the signature are fully verified to be valid, the client can happily show it to users.

# Staking Rewards and a proof of how they work

As mentioned in the spec, many actions taken by a user will involve redistributing some funds as rewards
to "all other stakers". To accomplish this, an algorithm has been developed which works as follows:


Assume `n` number of users (denoted as <code>u<sub>1</sub>, u<sub>2</sub>, ... u<sub>n</sub></code>) have deposited a total amount of CAW denoted as `totalDepositedCaw`
When an arbitrary user, <code>u<sub>i</sub></code>, removes `X` caw from their balance and distributes this amount as rewards to all other users,
the amount added to the account of any arbitrary user (<code>u<sub>j</sub></code>, where `j â‰  i`) will be `X` multiplied by <code>percentOwnership(u<sub>j</sub>)</code>,
where <code>percentOwnership(u<sub>j</sub>)</code> is the ratio of the balance of <code>u<sub>j</sub></code> to the total amount of CAW which has been deposited by all users aside from <code>u<sub>i</sub></code>. 


<pre><code>percentOwnership(u<sub>j</sub>) = balanceOf(u<sub>j</sub>) / (totalDepositedCaw - balanceOf(u<sub>i</sub>))
</code></pre>


The `balanceAfterReward` of <code>u<sub>j</sub></code> can be denoted as follows:

<pre><code>balanceAfterReward(u<sub>j</sub>) = balanceOf(u<sub>j</sub>) + X * percentOwnership(u<sub>j</sub>)
</code></pre>


i.e.

<pre><code>balanceAfterReward(u<sub>j</sub>) = balanceOf(u<sub>j</sub>) + X * balanceOf(u<sub>j</sub>) / (totalDepositedCaw - balanceOf(u<sub>i</sub>))
</code></pre>


therefore

<pre><code>balanceAfterReward(u<sub>j</sub>) = balanceOf(u<sub>j</sub>) * (1 + X / (totalDepositedCaw - balanceOf(u<sub>i</sub>))
</code></pre>


if

<pre><code>r = (1 + X / (totalDepositedCaw - balanceOf(u<sub>i</sub>))
</code></pre>


then


<pre><code>balanceAfterReward(u<sub>j</sub>) = balanceOf(u<sub>j</sub>) * r
</code></pre>


Since each amount distributed as rewards can be different, we can denote each amount as <code>X<sub>n</sub></code>, and 


<pre><code>r<sub>n</sub> = (1 + X<sub>n</sub> / (totalDepositedCaw<sub>n</sub> - balance<sub>n</sub>(u<sub>i</sub>))
</code></pre>


and therefore


<pre><code>balanceOf<sub>(n+1)</sub>(u<sub>j</sub>) = balanceOf<sub>n</sub>(u<sub>j</sub>) * r<sub>n</sub>
...
balanceOf<sub>3</sub>(u<sub>j</sub>) = balanceOf<sub>2</sub>(u<sub>j</sub>) * r<sub>2</sub>
balanceOf<sub>2</sub>(u<sub>j</sub>) = balanceOf<sub>1</sub>(u<sub>j</sub>) * r<sub>1</sub>
balanceOf<sub>1</sub>(u<sub>j</sub>) = balanceOf<sub>0</sub>(u<sub>j</sub>) * r<sub>0</sub>
</code></pre>


and by substitution, we can compute <code>balance<sub>3</sub></code> as:


<pre><code>balanceOf<sub>3</sub>(u<sub>j</sub>) = balanceOf<sub>2</sub>(u<sub>j</sub>) * r<sub>2</sub>
balanceOf<sub>3</sub>(u<sub>j</sub>) = balanceOf<sub>1</sub>(u<sub>j</sub>) * r<sub>1</sub> * r<sub>2</sub>
balanceOf<sub>3</sub>(u<sub>j</sub>) = balanceOf<sub>0</sub>(u<sub>j</sub>) * r<sub>0</sub> * r<sub>1</sub> * r<sub>2</sub>
</code></pre>


To compute the current value of any user at any time,
we just need to multiply it's initial balance by the product of all <code>r<sub>0</sub>...r<sub>n</sub></code>.
In the solidity contract, we are only ever interested in the current balance,
so we can persist a value, <code>rewardMultipler<sub>n</sub></code>, which is overwritten with with each reward distribution `n` as

<pre><code>rewardMultiplier<sub>n</sub> = rewardMultiplier<sub>(n-1)</sub> * r<sub>n</sub>
</code></pre>

which is equivalent to

<pre><code>rewardMultipler<sub>n</sub> = r<sub>0</sub> * r<sub>1</sub> * ... * r<sub>n</sub>
</code></pre>


and therefore, at any time

<pre><code>balanceOf<sub>n</sub>(u<sub>j</sub>) = balanceOf<sub>0</sub>(u<sub>j</sub>) * rewardMultipler<sub>n</sub>
</code></pre>

--
    
The one other piece of this algorithm that needs to be considered is the balance of <code>u<sub>i</sub></code>, 
after <code>u<sub>i</sub></code> distributes `X` from it's balance, it should receive no part of `X`, and must be
overwritten as it's pre-distribution balance minus `X`. Since the current balance of each <code>u<sub>n</sub></code>
is computed by multiplying `rewardMultipler`, we must overwrite the initial balance of <code>u<sub>i</sub></code>
to be in terms of <code>rewardMultipler<sub>n</sub></code>. Namely,


<pre><code>balanceOf<sub>0</sub>(u<sub>i</sub>) = (balanceOf<sub>n-1</sub>(u<sub>i</sub>) - X<sub>n</sub>) / rewardMultipler<sub>n</sub>
</code></pre>


Since the spec requires several transactions to move funds between users while simultaneously redistributing
rewards to all other stakers, the contract uses this process of overwriting <code>balanceOf<sub>0</sub></code>
in terms of <code>rewardMultipler<sub>n</sub></code> anytime a user receives, spends, deposits, or withdraws
any CAW from their balance.






...

...

(p.s. I dedicate this proof to my grlfren, who not only endured me writing it, but also helped)

